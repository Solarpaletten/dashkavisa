# Архитектура проекта visa_bot

**Версия документа:** v0.1  
**Дата:** Январь 2026

---

## Класс проекта

**Automation Worker** — фоновый процесс, выполняющий автоматизированные действия на внешнем веб-сайте с оповещением через Telegram.

Это **НЕ веб-приложение**, **НЕ API-сервис**, **НЕ SaaS-продукт**.

---

## Общая схема

```
┌─────────────────┐
│   Пользователь  │
│   (Telegram)    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Telegram Bot   │
│  (Python)       │
│  main.py        │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Automation     │
│  Layer          │
│  browser.py     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Selenium       │
│  + ChromeDriver │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  VFS Global     │
│  (внешний сайт) │
└─────────────────┘
```

---

## Компоненты системы

### 1. Telegram Bot Layer

**Файл:** `main.py`

Отвечает за:
- Приём команд от пользователя
- Отправку уведомлений
- Управление подписками
- Планирование периодических проверок (job_queue)

**Технология:** python-telegram-bot

### 2. Automation Layer

**Файл:** `automation/browser.py`

Отвечает за:
- Настройку браузера Chrome
- Авторизацию на VFS Global
- Навигацию по страницам
- Парсинг доступных слотов
- Создание скриншотов для отладки

**Технология:** Selenium WebDriver

### 3. Configuration Layer

**Файл:** `config.py`, `.env`

Отвечает за:
- Хранение учётных данных
- Параметры работы бота
- Пути к директориям

---

## Почему выбран текущий стек

### Python + Selenium

**Причины выбора:**
- Selenium — зрелый инструмент для browser automation
- Большое сообщество и документация
- Простота интеграции с python-telegram-bot
- Возможность работы с реальным браузером (не headless)

**Ограничения:**
- Selenium детектируется защитой Cloudflare
- Требует установленного Chrome/Chromium
- Ресурсоёмкий (запуск полноценного браузера)

### Почему НЕ веб-приложение

- Проект не требует веб-интерфейса
- Взаимодействие только через Telegram
- Нет необходимости в базе данных для множества пользователей
- Усложнение архитектуры не оправдано для single-user сценария

### Почему НЕ Next.js

- Next.js — фреймворк для веб-приложений
- Проект не имеет веб-интерфейса
- Browser automation в Node.js (Puppeteer/Playwright) не даёт преимуществ для данной задачи
- Смена стека требует переписывания всей логики

---

## Жизненный цикл процесса

### Запуск

1. Загрузка конфигурации из `.env`
2. Инициализация Telegram-бота
3. Регистрация обработчиков команд
4. Запуск планировщика проверок
5. Запуск polling (ожидание сообщений)

### Проверка слотов

1. Создание экземпляра браузера
2. Переход на страницу авторизации VFS
3. Ввод учётных данных
4. Ожидание прохождения защиты (Cloudflare)
5. Переход в раздел записи
6. Парсинг доступных дат
7. Сравнение с предыдущим состоянием
8. Отправка уведомления (если есть новые слоты)
9. Закрытие браузера

### Завершение

1. Остановка планировщика
2. Закрытие всех сессий браузера
3. Сохранение состояния

---

## Хранение данных

| Данные | Формат | Расположение |
|--------|--------|--------------|
| Конфигурация | .env | корень проекта |
| Подписчики | JSON | data/subscribers.json |
| Данные пользователей | TXT | users/ |
| Логи | TXT | logs/ |
| Скриншоты | PNG | logs/screenshots/ |

---

## Внешние зависимости

| Сервис | Назначение | Критичность |
|--------|------------|-------------|
| Telegram API | Отправка/приём сообщений | Критическая |
| VFS Global | Целевой сайт | Критическая |
| Cloudflare | Защита VFS Global | Блокирующая |

---

## Известные архитектурные ограничения

1. **Single-instance** — проект не рассчитан на параллельный запуск
2. **Single-user** — один набор учётных данных VFS
3. **Нет персистентности сессий** — каждая проверка создаёт новую сессию браузера
4. **Зависимость от DOM** — изменения на сайте VFS требуют обновления селекторов

---

## Принятые архитектурные решения

| Решение | Обоснование |
|---------|-------------|
| Monolith | Простота для single-user сценария |
| JSON вместо DB | Минимальный объём данных |
| Selenium вместо requests | Необходимость JS-рендеринга |
| Polling вместо webhook | Простота деплоя |

---

*Документ зафиксирован для версии v0.1. Изменения архитектуры требуют согласования с архитектором.*
